## ✔ 권가의 개발 공부 기록입니다.

>피드백은 항상 환영입니다. 감사합니다 !!

<!-- 정리해야하는 부분 기록..-->
<!-- 운영체제 : 데드락, 뮤텍스, 세마포어 개념 정리하기... 메리크리스마스 @@@! nestjs 순환 종속성 관련해서 정리하기, 프로젝트 로그인 부분 트러블  아 깃 이그노어 진짜   -->


</br>

<!-- ✔ <hr> -->
## ✔ 구성  

[JavaScript](#JavaScript)  
[NodeJS](#NodeJS)  /  [Express](#Express)  
<!-- [TypeScript](#TypeScript) -->
[Data Base](#DataBase)  
[CS](#CS)  
[JWT](#JWT)

<!-- [Algorithms](#Algorithms) -->
</br></br>

***

</br></br>

### [JavaScript](./src/JS/JavaScript.md)
* [Async](./src/JS/Async.md)
* [CallBack](./src/JS/CallBack.md)
* [Class](./src/JS/Class.md)
* [Data Type](./src/JS/DataType.md)
* [Hoisting](./src/JS/Hoisting.md)
* [Module](./src/JS/Module.md)
* [Object](./src/JS/Object.md)
* [Promise](./src/JS/Promise.md)
* [Regular Expression](./src/JS/Regular_Expression.md) [\[자주쓰는 정규표현식 보러가기\]](./src/JS/Regular_Expression2.md)
* [RunTime](./src/JS/Runtime.md)
* [Template Literal](./src/JS/TemplateLiteral.md)
* [Type Casting](./src/JS/TypeCasting.md)   
* [오류처리](./src/JS/Error.md)
<!-- * 암호화 https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-crypto-%EB%AA%A8%EB%93%88-%EC%95%94%ED%98%B8%ED%99%94#%EC%95%94%ED%98%B8%ED%99%94%EC%97%90_%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94_%EB%A9%94%EC%86%8C%EB%93%9C -->
* <details><summary> Method</summary>
  <div markdown="1">

  * [Array.indexOf()](./src/JS/Method/Array.indexOf().md)
  * [Array.isArray()](./src/JS/Method/Array.isArray().md)
  * [Array.pop()](./src/JS/Method/Array.pop().md)
  * [Array.push()](./src/JS/Method/Array.push().md)
  * [Array.shift()](./src/JS/Method/Array.shift().md)
  * [Array.unshift()](./src/JS/Method/Array.unshift().md)
  * [JSON.parse()](./src/JS/Method/JSON.parse().md)
  </div>
  </details>


 
<br>

### [NodeJS](./src/NodeJS/NodeJS.md) [( Why Node JS ? )](https://github.com/kwon-ga/TIL/blob/master/src/NodeJS/why.md)
* [Bcrypt](./src/NodeJS/Bcrypt.md)
* [dotenv](./src/NodeJS/dotenv.md)
* [Jest](./src/NodeJS/Jest.md)
* [package.json](./src/NodeJS/package.json.md)
* [Prettier](./src/NodeJS/Prettier.md)
* [Sequelize](./src/NodeJS/Sequelize.md)
* [Socket.IO](./src/NodeJS/Socket.IO.md)
  <!-- * [joi](-) // 업데이트해야함 !!  https://joi.dev/api/?v=17.6.1 -->
<!--crypto -->
* #### [Express](./src/NodeJS/Express/Express.md)
  * [3-Layer-Architecture](src/NodeJS/Express/3-Layer-Architecture.md)
  * [Cookie](./src/NodeJS/Express/Cookie.md)
  * [Middleware](./src/NodeJS/Express/Middleware.md) [\[예제 보러가기\]](./src/NodeJS/Express/Middleware_example.md)
  * [Session](./src/NodeJS/Express/Session.md)

<br>

### [TypeScript](./src/typescript/TypeScript.md)

<br>

### [DataBase](./src/DataBase/DataBase.md) 
  * [SQL과 NoSQL](./src/DataBase/SQL_NoSQL.md)
  * [ORM과 ODM](./src/DataBase/ORM_ODM.md)
* [My SQL](./src/DataBase/MySQL/MySQL.md)
  * [제약 조건](./src/DataBase/MySQL/Constraint.md)
  * DDL (Data Definition Language)
    * [CREATE](./src/DataBase/MySQL/CREATE.md)
    * [ALTER](./src/DataBase/MySQL/ALTER.md)
    * [DROP](./src/DataBase/MySQL/DROP.md)
  * DML (Data Manipulation Language)
    * [SELECT](./src/DataBase/MySQL/SELECT.md)
    * [INSERT](./src/DataBase/MySQL/INSERT.md)
    * [UPDATE](./src/DataBase/MySQL/UPDATE.md)
    * [DELETE](./src/DataBase/MySQL/DELETE.md)
  <!-- * DCL (Data Control Language)
    * [GRANT](./src/DataBase/MySQL/GRANT.md)
    * [REVOKE](./src/DataBase/MySQL/REVOKE.md)
    * [COMMIT](./src/DataBase/MySQL/COMMIT.md)
    * [ROLLBACK](./src/DataBase/MySQL/ROLLBACK.md) -->
<!-- * #### [MongoDB]()
  * [-](-) -->

<br>

### CS
* [API](./src/CS/API.md)
* [Cookie_Session](./src/CS/Cookie_Session.md)
* [ElasticSearch](./src/CS/ElasticSearch.md)
* [HTTP](./src/CS/HTTP.md)
* [ObjectOriented](./src/CS/ObjectOriented.md)
* [Socket](./src/CS/Socket.md)
* [Static_Dynamic](./src/CS/Static_Dynamic.md)
* [Sync_Async](./src/CS/Sync_Async.md)
* [TCP와 UDP](./src/CS/TCP_UDP.md)

<br>

###  [JWT](https://jwt.io/)
  * [JWT 개요](./src/JWT/JWT.md)
[\[예제 보러가기\]](./src/JWT/JWT_example.md)
  * [Access Token](./src/JWT/AccessToken.md)
  * [Refresh Token](./src/JWT/RefreshToken.md)
[\[예제 보러가기\]](./src/JWT/Token_example.md)


<!-- <br><br>

### ✅ Interview

<br>

- [ ] 01장 : 시간복잡도와 공간복잡도
- [X] 02장 : [스택, 큐 자료구조](src/Interview/02.md)
- [X] 03장 : [배열, 링크드리스트](src/Interview/03.md)
- [X] 04장 : [트랜잭션](src/Interview/04.md)
- [X] 05장 : [정규화](src/Interview/05.md)
- [X] 06장 : [CORS](src/Interview/06.md)
- [X] 07장 : [var, let, const](src/Interview/07.md)
- [X] 08장 : [Promise](src/Interview/08.md)
- [X] 09장 : [Hoisting](src/Interview/09.md)
- [ ] 10장 : [async await](src/Interview/0.md)

---

- [ ] 11장 : Arrow Function
- [ ] 12장 : ‘==’와 ‘===’
- [ ] 13장 : Express
- [ ] 14장 : npm
- [ ] 15장 : web server, NGINX, Apache
- [ ] 16장 : 동기와 비공기
- [ ] 17장 : 모든 요소에 인덱스를 걸지 않는 이유
- [ ] 18장 : 이분탐색
- [ ] 19장 : 트리, 그래프
- [ ] 20장 : 인덱스의 원리

---

- [ ] 21장 : 복합인덱스
- [ ] 22장 : HTTP HTTPS
- [ ] 23장 : TCP 3 way handshake
- [ ] 24장 : TCP UDP
- [ ] 25장 : Base64 인코딩
- [ ] 26장 : 프로세스와 스레드
- [ ] 27장 : Call by reference
- [ ] 28장 : 동시성과 병렬성
- [ ] 29장 : 깊은 복사와 얕은 복사
- [ ] 30장 : JS의 passed by value 와 passed by reference

---

- [ ] 31장 : 고차함수
- [ ] 32장 : JWT
- [ ] 33장 : Node JS
- [ ] 34장 : 이벤트 루프
- [ ] 35장 : 트랜스파일러와 번들러 -->

<!--
###  Algorithms
* <details><summary> Math </summary>
  <div markdown="2">

  <!-- * [Bit Manipulation](src/algorithms/math/bits.md) - 비트 쪼개기! -->
  <!-- * `B` [팩토리얼](src/algorithms/math/factorial.md) -->
  <!-- * `B` [피보나치 수](src/algorithms/math/fibonacci)
  * `B` [소수 판별](src/algorithms/math/primality-test) (trial division 방식)
  * `B` [유클리드 호제법](src/algorithms/math/euclidean-algorithm) - 최대공약수 (GCD)
  * `B` [최소 공배수](src/algorithms/math/least-common-multiple) - LCM
  * `B` [에라토스테네스의 체](src/algorithms/math/sieve-of-eratosthenes) - 특정수 이하의 모든 소수 찾기
  * `B` [2의 거듭제곱 판별법](src/algorithms/math/is-power-of-two) - 어떤 수가 2의 거듭제곱인지 판별 (naive 와 bitwise 알고리즘)
  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle)
  * `A` [자연수 분할](src/algorithms/math/integer-partition)
  * `A` [리우 후이 π 알고리즘](src/algorithms/math/liu-hui) - N-각형을 기반으로 π 근사치 구하기 -->
  <!-- </div>
  </details>
* <details><summary> Sets</summary>
  <div markdown="3">
   -->
  <!-- * `B` [카티지언 프로덕트](src/algorithms/sets/cartesian-product) - 곱집합
  * `B` [Fisher–Yates 셔플](src/algorithms/sets/fisher-yates) - 유한 시퀀스의 무작위 순열
  * `A` [멱집합](src/algorithms/sets/power-set) - 집합의 모든 부분집합
  * `A` [순열](src/algorithms/sets/permutations) (반복 유,무)
  * `A` [조합](src/algorithms/sets/combinations) (반복 유,무)
  * `A` [최장 공통 부분수열](src/algorithms/sets/longest-common-subsequence) (LCS)
  * `A` [최장 증가 수열](src/algorithms/sets/longest-increasing-subsequence)
  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence) (SCS)
  * `A` [배낭 문제](src/algorithms/sets/knapsack-problem) - "0/1" 과 "Unbound"
  * `A` [최대 구간합](src/algorithms/sets/maximum-subarray) - "브루트 포스" 과 "동적 계획법" (Kadane's) 버전
  * `A` [조합 합](src/algorithms/sets/combination-sum) - 특정 합을 구성하는 모든 조합 찾기 -->
  <!-- </div>
  </details>

* <details><summary> String</summary>
  <div markdown="4"> -->

  <!-- * `B` [해밍 거리](src/algorithms/string/hamming-distance) - 심볼이 다른 위치의 갯수
  * `A` [편집 거리](src/algorithms/string/levenshtein-distance) - 두 시퀀스 간위 최소 편집거리
  * `A` [커누스-모리스-프랫 알고리즘](src/algorithms/string/knuth-morris-pratt) (KMP 알고리즘) - 부분 문자열 탐색 (패턴 매칭)
  * `A` [Z 알고리즘](src/algorithms/string/z-algorithm) - 부분 문자열 탐색 (패턴 매칭)
  * `A` [라빈 카프 알고리즘](src/algorithms/string/rabin-karp) - 부분 문자열 탐색
  * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring)
  * `A` [정규 표현식 매칭](src/algorithms/string/regular-expression-matching) -->
  
  <!-- </div>
  </details>

* <details><summary> Searches</summary>
  <div markdown="5"> -->

  <!-- * `B` [선형 탐색](src/algorithms/search/linear-search)
  * `B` [점프 탐색](src/algorithms/search/jump-search) (or Block Search) - 정렬된 배열에서 탐색
  * `B` [이진 탐색](src/algorithms/search/binary-search) - 정렬된 배열에서 탐색
  * `B` [보간 탐색](src/algorithms/search/interpolation-search) - 균등한 분포를 이루는 정렬된 배열에서 탐색
   -->
  <!-- </div>
  </details>

* <details><summary> Sorting</summary>
  <div markdown="5"> -->

  <!-- * `B` [거품 정렬](src/algorithms/sorting/bubble-sort)
  * `B` [선택 정렬](src/algorithms/sorting/selection-sort)
  * `B` [삽입 정렬](src/algorithms/sorting/insertion-sort)
  * `B` [힙 정렬](src/algorithms/sorting/heap-sort)
  * `B` [병합 정렬](src/algorithms/sorting/merge-sort)
  * `B` [퀵 정렬](src/algorithms/sorting/quick-sort) - 제자리(in-place)와 제자리가 아닌(non-in-place) 구현
  * `B` [셸 정렬](src/algorithms/sorting/shell-sort)
  * `B` [계수 정렬](src/algorithms/sorting/counting-sort)
  * `B` [기수 정렬](src/algorithms/sorting/radix-sort) -->
  
  <!-- </div>
  </details>

* <details><summary> Trees</summary>
  <div markdown="5"> -->

  <!-- * `B` [깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)
  * `B` [너비 우선 탐색](src/algorithms/tree/breadth-first-search) (BFS) -->
  
  <!-- </div>
  </details>

* <details><summary> Graphs</summary>
  <div markdown="5"> -->

  <!-- * `B` [깊이 우선 탐색](src/algorithms/graph/depth-first-search) (DFS)
  * `B` [너비 우선 탐색](src/algorithms/graph/breadth-first-search) (BFS)
  * `B` [크루스칼 알고리즘](src/algorithms/graph/kruskal) - 최소 신장 트리 찾기 (MST) 무방향 가중 그래프
  * `A` [다익스트라 알고리즘](src/algorithms/graph/dijkstra) - 한 점에서 다른 모든 점까지 최단 거리 찾기
  * `A` [벨만-포드 알고리즘](src/algorithms/graph/bellman-ford) - 한 점에서 다른 모든 점까지 최단 거리 찾기
  * `A` [플로이드-워셜 알고리즘](src/algorithms/graph/floyd-warshall) - 모든 종단 간의 최단거리 찾기
  * `A` [사이클 탐지](src/algorithms/graph/detect-cycle) - 유방향, 무방향 그래프 (DFS 와 Disjoint Set 에 기반한 버전)
  * `A` [프림 알고리즘](src/algorithms/graph/prim) - 무방향 가중치 그래프에서 최소 신장 트리 (MST) 찾기
  * `A` [위상 정렬](src/algorithms/graph/topological-sorting) - DFS 방식
  * `A` [단절점](src/algorithms/graph/articulation-points) - 타잔의 알고리즘 (DFS 기반)
  * `A` [단절선](src/algorithms/graph/bridges) - DFS 기반 알고리즘
  * `A` [오일러 경로 와 오일러 회로](src/algorithms/graph/eulerian-path) - Fleury의 알고리즘 - 모든 엣지를 한번만 방문
  * `A` [해밀턴 경로](src/algorithms/graph/hamiltonian-cycle) - 모든 꼭짓점을 한번만 방문
  * `A` [강결합 컴포넌트](src/algorithms/graph/strongly-connected-components) - Kosaraju의 알고리즘
  * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기 -->
  
  <!-- </div>
  </details>

* <details><summary> Uncategorized</summary>
  <div markdown="5"> -->

  <!-- * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower)
  * `B` [정방 행렬 회전](src/algorithms/uncategorized/square-matrix-rotation) - 제자리(in-place) 알고리즘
  * `B` [점프 게임](src/algorithms/uncategorized/jump-game) - 백트래킹, 동적계획법 (top-down + bottom-up), 탐욕 알고리즘 예제
  * `B` [Unique 경로](src/algorithms/uncategorized/unique-paths) - 백트래킹, 동적계획법, 파스칼 삼각형에 기반한 예제
  * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem (동적계획법, 브루트포스 버전)
  * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)
  * `A` [기사의 여행 문제](src/algorithms/uncategorized/knight-tour) -->
  
  <!-- </div>
  </details> -->




<!-- 
### 패러다임별 알고리즘

알고리즘 패러다임 이란, 알고리즘이 주어진 문제를 해결하기 위해 채택한 기초가 되는 일반적인 방법 혹은 접근법입니다. 알고리즘이 해결하는 문제나 알고리즘의 동작 방식이 완전히 다르더라도,알고리즘의 동작 원칙이 같으면 같은 패러다음을 사용했다고 말할 수 있으며, 주로 알고리즘을 구분하는 기준으로 쓰인다. 알고리즘이 일반적인 컴퓨터의 프로그램에 대한 개념보다 보다 더 추상적인 개념인 것처럼 알고리즘의 패러다임은 명확히 정의된 수학적 실체가 있는 것이 아니기 때문에 그 어떤 알고리즘의 개념보다도 훨씬 추상적인 개념입니다.

* **브루트 포스(Brute Force)** - 가능한 모든 경우를 탐색한 뒤 최적을 찾아내는 방식입니다.
  * `B` [선형 탐색](src/algorithms/search/linear-search)
  * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem
  * `A` [최대 구간합](src/algorithms/sets/maximum-subarray)
  * `A` [외판원 문제](src/algorithms/graph/travelling-salesman) - 각 도시를 다 방문하고 다시 출발점으로 돌아오는 최단 경로 찾기
* **탐욕 알고리즘(Greedy)** - 이후를 고려하지 않고 현재 시점에서 가장 최적인 선택을 하는 방식입니다.
  * `B` [점프 게임](src/algorithms/uncategorized/jump-game)
  * `A` [쪼갤수 있는 배낭 문제](src/algorithms/sets/knapsack-problem)
  * `A` [다익스트라 알고리즘](src/algorithms/graph/dijkstra) - 모든 점 까지의 최단거리 찾기
  * `A` [프림 알고리즘](src/algorithms/graph/prim) - 무방향 가중치 그래프에서 최소 신창 트리 (MST) 찾기
  * `A` [크루스칼 알고리즘](src/algorithms/graph/kruskal) - 무방향 가중치 그래프에서 최소 신창 트리 (MST) 찾기
* **분할 정복법(Divide and Conquer)** - 문제를 여러 작은 문제로 분할한 뒤 해결하는 방식입니다.
  * `B` [이진 탐색](src/algorithms/search/binary-search)
  * `B` [하노이 탑](src/algorithms/uncategorized/hanoi-tower)
  * `B` [파스칼 삼각형](src/algorithms/math/pascal-triangle)
  * `B` [유클리드 호제법](src/algorithms/math/euclidean-algorithm) - 최대공약수 계산 (GCD)
  * `B` [병합 정렬](src/algorithms/sorting/merge-sort)
  * `B` [퀵 정렬](src/algorithms/sorting/quick-sort)
  * `B` [트리 깊이 우선 탐색](src/algorithms/tree/depth-first-search) (DFS)
  * `B` [그래프 깊이 우선 탐색](src/algorithms/graph/depth-first-search) (DFS)
  * `B` [점프 게임](src/algorithms/uncategorized/jump-game)
  * `A` [순열](src/algorithms/sets/permutations) (반복 유,무)
  * `A` [조합](src/algorithms/sets/combinations) (반복 유,무)
* **동적 계획법(Dynamic Programming)** - 이전에 찾은 결과를 이용하여 최종적으로 해결하는 방식입니다.
  * `B` [피보나치 수](src/algorithms/math/fibonacci)
  * `B` [점프 게임](src/algorithms/uncategorized/jump-game)
  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)
  * `B` [빗물 담기 문제](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem
  * `A` [편집 거리](src/algorithms/string/levenshtein-distance) - 두 시퀀스 간의 최소 편집 거리
  * `A` [최장 공통 부분 수열](src/algorithms/sets/longest-common-subsequence) (LCS)
  * `A` [최장 공통 부분 문자열](src/algorithms/string/longest-common-substring)
  * `A` [최장 증가 수열](src/algorithms/sets/longest-increasing-subsequence)
  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence)
  * `A` [0/1 배낭 문제](src/algorithms/sets/knapsack-problem)
  * `A` [자연수 분할](src/algorithms/math/integer-partition)
  * `A` [최대 구간합](src/algorithms/sets/maximum-subarray)
  * `A` [벨만-포드 알고리즘](src/algorithms/graph/bellman-ford) - 모든 점 까지의 최단 거리 찾기
  * `A` [플로이드-워셜 알고리즘](src/algorithms/graph/floyd-warshall) - 모든 종단 간의 최단거리 찾기
  * `A` [정규 표현식 매칭](src/algorithms/string/regular-expression-matching)
* **백트래킹(Backtracking)** - 모든 가능한 경우를 고려한다는 점에서 브루트 포스와 유사합니다. 하지만 다음 단계로 넘어갈때 마다 모든 조건을 만족했는지 확인하고 진행합니다. 만약 조건을 만족하지 못했다면 뒤로 돌아갑니다 (백트래킹). 그리고 다른 경로를 선택합니다. 보통 상태를  유지한 DFS 탐색을 많이 사용합니다.
  * `B` [점프 게임](src/algorithms/uncategorized/jump-game)
  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)
  * `A` [해밀턴 경로](src/algorithms/graph/hamiltonian-cycle) - 모든 점을 한번씩 방문
  * `A` [N-Queens 문제](src/algorithms/uncategorized/n-queens)
  * `A` [기사의 여행](src/algorithms/uncategorized/knight-tour)
  * `A` [조합 합](src/algorithms/sets/combination-sum) - 특정 합을 구성하는 모든 조합 찾기
* **분기 한정법** - 백트래킹으로 찾은 각 단계의 최소 비용이 드는 해를 기억해 두고 있다가, 이 비용을 이용해서 더 낮은 최적의 해를 찾습니다. 기억해둔 최소 비용들을 이용해 더 높은 비용이 드는 해결법을 탐색 안함으로써 불필요한 시간 소모를 줄입니다. 보통 상태 공간 트리의 DFS 탐색을 이용한 BFS 탐색 방식에서 사용됩니다. --> 
