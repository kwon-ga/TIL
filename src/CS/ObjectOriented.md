## ✔ 객체 지향 (Object Oriented Programming, OOP)

<br>

### ✔ 객체 지향이란?

<br>

프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 객체라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식이다.

객체는 하나의 역할을 수행하는 메소드와 변수(데이터)의 묶음으로 봐야한다.

-> 책임과 권한을 가진 객체들이 서로 메세지를 주고받으며 협력해서 필요한 기능을 수행하도록 시스템을 개발하는 것

객체 지향 프로그래밍을 하면 크고 복잡한 시스템을 효과적으로 분해, 구성할 수 있고, 손쉽게 이해하고 효율적으로 다룰 수 있게 도와준다.

<br>

### ✔ 객체 지향적인 소프트웨어 구분

<br>

캡슐화, 다형성, 클래스 상속을 지원하는가?

데이터 접근 제한을 걸 수 있는가?

를 충족하면 객체 지향적인 소프트웨어라고 볼 수 있다.

<br>

### ✔ 캡슐화 (Encapsulation)

<br>

캡슐화는 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 의미한다.

캡슐화의 가장 큰 이유는 정보 은닉을 목적으로 한다.

<br>

### ✔ 상속 (Inheritance)

<br>

상속은 이미 정의된 ***상위 클래스의*** 특징을 하위 클래스에서 물려받아 코드의 중복을 제거하고, 코드의 재사용성을 증대시킨다.

즉, 하나의 상위 클래스가 가진 요소(함수, 변수 및 데이터)를 다른 클래스가 그대로 물려 받는 것을 말한다.



<br>

### ✔ 다형성 (Polymorphism)

<br>

다형성은 객체(클래스)가 연산을 수행하게 될때 하나의 행위에 대해 각 객체가 가지고 있는 고유한 특성으로 다른 여러 형태로 재구성 되는 것을 말한다.

즉, 동일한 메소드의 이름을 사용하지만 메소드에 대해 클래스마다 다르게 구현되는 개념이 다형성이다.

Java의 오버로딩(Overloading), 오버라이딩(Overriding)가 대표적인 다형성의 예다.

<br>

### ✔ 의존성 (Dependency)

<br>

객체 (모듈 및 클래스)들이 협력하는 과정 속에서 해당 객체들이 다른 객체를 의존하게 되는 정도를 나타낸다.

의존성은 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체들도 함께 변경될 수 있다는 사실이 내포되어있다.

<br>

### ✔ 결합도 (Coupling)

<br>

결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 읜존성을 가지고 있는지를 나타낸다.

객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다.  
객체들이 합리적인 수준으로 의존할 경우 결합도가 낮다고 말한다.

결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경이 힘들다.

<br>

### ✔ 응집도 (Cohesion)

<br>

응집도는 모듈에 포함된 내부 요소들이 각각 연관되어 있는 관계를 정도로 나타낸다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에 위임하는 객체를 응집도가 높다고 한다.

1개의 메소드가 내부에서 변수를 많이 사용할 수록 해당 메소드와 클래스는 응집도가 높아지게된다.

<br>

***

<br>

### ✔ 프로그래밍 패러다임

프로그래밍의 대표적인 패러다임은 크게 세 종류가 있다.

1.구조적 프로그래밍 (Structured Programming)  
2.객체 지향 프로그래밍 (Object-Oriented Programming, OOP)  
3.함수형 프로그래밍 (Functional Programming)

<br>

**구조적 프로그래밍**은 **제어 흐름**의 **직접적인 전환**에 대한 규칙을 제시한다.

- **구조적 프로그래밍**은 **기능**을 중심적으로 개발을 진행한다.
- **구조적 프로그래밍**은 프로그래밍이라는 기술이 시작되면서 가장 처음으로 **적용**된 패러다임이다.

**객체 지향 프로그래밍**은 **제어흐름**의 **간접적인 전환**에 대한 규칙을 제시한다.

- **객체 지향 프로그래밍**은 프로그램의 처리단위가 **객체**인 프로그래밍 방법이다.
- **객체 지향 프로그래밍**은 “**현실 세계를 모델링**”하는 대표적인 프로그래밍 패러다임이다.

**함수형 프로그래밍**은 **할당문**에 대한 규칙을 제시한다.

- **함수형 프로그래밍**은 **함수**를 중심적으로 개발을 진행한다.
- **함수형 프로그래밍**은 3가지의 패러다임 중 가장 처음 만들어졌지만 최근들어 겨우 도입되기 시작하는 패러다임이다.

<br>

***

<br>

### ✔ 객체 지향 프로그래밍

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍이라고 부른다.

- **객체 지향 프로그래밍**은 **코드를 추상화**해 직관적으로 사고할 수 있기 때문에, **대표적인 프로그래밍 방법론**으로 적용되고 있습니다.
- **객체 지향 프로그래밍**에서는 자동차, 동물, 사람 등과 같은 **현실 세계의 객체**를 유연하게 **표현**할 수 있습니다.
- **객체**는 어떠한 **특성**을 가지고 있으며 특정 **기능을 수행**할 수 있습니다.
- 자동차는 **객체**이고, 출발, 정지, 운행 및 제동과 같은 **기능**을 수행할 수 있습니다.

<br>

### ✔ 객체 지향 설계 5원칙

<br>

**SOLID**

- **단일 책임의 원칙 (Single Responsibility Principle, SRP)**
- **개방-폐쇄 원칙 (Open-Closed Principle, OCP)**
- **리스코프 치환 원칙 (Liskov substitution principle, LSP)**
- **인터페이스 분리 원칙 (Interface segregation principle, ISP)**
- **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**


<br>

### ✔ 단일 책임의 원칙 (Single Responsibility Principle, SRP)

<br>

**하나의 객체는 단 하나의 책임을 가져야 한다.**

즉, **클래스**나 **모듈**을 **변경할 이유**가 **단 하나** 뿐이어야 한다는 원칙입니다.

**SRP**는 **책임**이라는 개념을 정의하며 **적절한 클래스의 크기**를 제시합니다.

**SRP**는 객체 지향설계에서 중요한 개념이고 이해하고 따르기 쉬운 개념이지만, 프로그래머가 가장 무시하는 규칙입니다.   
일반적인 프로그래머는 “**깨끗하고 우아하게 작성된 소프트웨어**"보다 “**동작하기만 하는 소프트웨어**"에 초점을 맞추기 때문입니다.

<br>

### ✔ 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

<br>

**소프트웨어 엔티티 또는 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**

- 즉, 소프트웨어 개체의 **행위**는 **확장**될 수 있어야 하지만, 개체를 **변경**해서는 **안됩니다.**
- 조금 더 쉽게 설명하자면, **기존 코드**에 영향을 주지않고 소프트웨어에 **새로운 기능**이나 **구성 요소**를 **추가**할 수 있어야 한다는 것입니다.

만약 요구사항을 **조금** 확장하는 데 소프트웨어를 **엄청나게 수정**해야 한다면, 소모되는 **개발 코스트**또한 **엄청나게 증가**할 것입니다.

<br>

### ✔ 리스코프 치환 원칙 (Liskov substitution principle, LSP)

<br>

**프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.**

여기서 **하위 타입**이란 **`S`** 타입의 객체 **o1** 각각에 대응하는 **`T`** 타입 객체 **o2**가 있고, **`T`** 타입을 이용해서 정의한 모든 프로그램 **`P`** 에서 **o2**의 자리에 **o1**을 치환하더라도 **`P`** 의 행위가 변하지 않는다면, **`S`** 는 **`T`** 의 하위 타입입니다.

**즉, `S`가 `T`의 하위 유형이면 해당 프로그램의 속성을 변경하지 않고 `T` 객체를 `S` 객체로 대체할 수 있습니다.**

만약 **부모 클래스**와 **자식 클래스**가 있는 경우 **서로를 바꾸더라도** 해당 프로그램에서 잘못된 결과를 도출하지 않는 것입니다.


<br>

### ✔ 인터페이스 분리 원칙 (Interface segregation principle, ISP)

<br>

**특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.**

즉, 클라이언트가 **필요하지 않는 기능**을 가진 **인터페이스**에 의존해서는 안 되고, 최대한 **인터페이스**를 **작게** 유지해야합니다.

조금 더 쉽게 설명하자면, 사용자가 **필요하지 않은 것**들에 **의존하지 않도록**, **인터페이스**를 **작게 유지**해야 한다는 것입니다.

<br>

### ✔ 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

<br>

**프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.**

**즉**, **높은 계층의 모듈(도메인)이 저수준의 모듈(하부구조)에 의존해서는 안된다.**

조금 더 자세하게 정리해보자면, 

1. **고수준 계층의 모듈**(도메인)은 **저수준 계층의 모듈**(하부구조)에 **의존**해서는 안된다. 둘 다 **추상화에 의존**해야 한다.
2. 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항은 추상화에 의존해야 한다.