## Stateful - 상태유지

<br>

클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미한다.

클라이언트의 이전 요청이 서버에 전달되었을 때 클라이언트의 다음 요청이 이전 요청과 관계가 이어지는 것을 의미한다.


</br>

***

</br>

## Stateless - 무상태
<br>
클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미한다.

<br>
Stateless 구조에서 server는 단순히 요청이 오면 응답을 보내주는 역할만 수행하며, 이러한 정보를 서버에 저장하지 않는다.

<br>
브라우저가 데이터를 전송할 때마다 연결하고 끊는 사이클을 의미한다.




</br>

***

</br>

### Stateful 예제
<br>
자전거를 사려는 클라이언트 A 와 자전거를 판매하는 서버 B 가 있으며, A 가 B 의 자전거를 산다고 가정한다. 

<br>

A : 자전거 사려합니다. <br>
B : 자전거 커스텀 재료를 골라주세요. (자전거를 사려한다는 것을 기억한다.) <br><br>
A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. <br>
B : 배송은 어디로 해드릴까요? (자전거를 사려했다는 것을 기억하고 있다.) <br><br>
A : 집으로 보내주세요.<br>
B : 결제는 무엇으로 해드릴까요? (자전거를 사려했다는 것, 커스텀을 어떻게 했는지 알고 있다.)<br><br>
A : 카드로 결제할게요<br>
B : 결제 완료 되었습니다. (위의 모든 사용자가 요구했던 사항을 기억하고 있다.)<br><br>
지극히 정상적인 대화처럼 보이며, 자전거를 판매하는 B 서버는 사용자의 이전 요청을 모두 기억하며 진행한다는 것을 알 수 있다.  
<br>

만약 판매하는 서버 B 가 바뀔 경우에 문제가 생긴다. 
<br>

예를들어 대규모의 트래픽이 몰려들어서 서버를 긴급하게 늘렸다고 가정한다.  
그러면, 판매자 서버가 B 가 아닌 증가된 어떤 서버 C 가 될 수도 있다.  
그렇게 된다면, 대화는 다음과 같이 진행된다.  
<br>
A : 자전거 사려합니다.<br>
B : 자전거 커스텀 재료를 골라주세요<br>
<br>
A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요.<br>
B : 예?<br><br>
A : 집으로 보내주세요.<br>
B : 예?<br><br>
A : 카드로 결제할게요<br>
B : 예?<br><br>


이를 해결하기 위해 무상태를 사용한다.

<br>

*** 

<br>

### Stateless 예제

<br>

동일하게, 자전거를 사려는 클라이언트 A 와 자전거를 판매하는 서버 B 가 있으며, A 가 B 의 자전거를 산다고 가정한다.  

<br>
A : 자전거 사려합니다.<br>
B : 자전거 커스텀 재료를 골라주세요. (서버는 아무것도 기억하지 않는다.)<br><br>
A : 자전거 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요.<br>
B : 배송은 어디로 해드릴까요? (서버는 아무것도 기억하지 않는다.)<br><br>
A : 자전거 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요.<br>
B : 결제는 무엇으로 해드릴까요? (서버는 아무것도 기억하지 않는다.)<br><br>
A : 자전거 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요. 결제는 카드로 결제할게요 <br>
B : 결제 완료 되었습니다. (서버는 이제 요청을 처리한다.) <br><br>

이전의 클라이언트의 요청을 유지하지 않는다는게 핵심이다.  


무상태는 기존의 서버가 혼잡해져서 새로운 서버를 가져다 놓아도, 계속 일을 처리할 수 있다.


단점은 클라이언트가 하고자하는 최종 목적을 위해, 전달해야하는 내용이 많아진다는 것이다.
