## ✔ Jest로 테스트 코드 작성하기

<br>

### ✅ 왜 테스트 코드를 짜야하는가?

<br>

기능 구현 후 예상한대로 작동하는지 확인하는 절차이며,  
예상하지 못한 오류를 잡아낼 수 있으며,  
리팩터링을 통해 코드의 가독성을 향상시킨다.  

<br>

### ✔ 테스트에 대하여 (feat: Clean Code)

- T1: 불충분한 테스트
    
    테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.
    테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.
    
- T2: 커버리지 도구를 사용하라
    
    커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다.
    커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기 쉬워진다.
    
- T3: 사소한 테스트를 건너뛰지 마라
    
    사소한 테스트는 짜기 쉽다. 
    사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다.
    
- T4: 무시한 테스트는 모호함을 뜻한다.
    
    때로는 요구사항이 불분명하기에 프로그램이 돌아가는 방식을 확신하기 어렵다. 
    불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 `@ignore`를 붙여 표현한다.
    
- T5: 경계 조건을 테스트하라
    
    경계 조건은 각별히 신경 써서 테스트한다. 
    알고리즘의 핵심 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다.
    
- T6: 버그 주변은 철저히 테스트하라
    
    버그는 서로 모이는 경향이 있다.
    한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.
    
- T7: 실패 패턴을 살펴라
    
    테스트 케이스가 실패하는 패턴으로 때때로 문제를 진단할 수 있다.
    합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.
    
- T8: 테스트 커버리지 패턴을 살펴라
    
    통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

<br>

***

<br>

### ✔ Mocking이란?

<br>

mocking이란 모조품이라는 뜻이다.

테스트하고자 하는 코드가 의존하는 function이나 class에 대해 모조품을 만들어 일단 동작하게 만든다.

즉, 해당 코드가 의존하는 부분을 가짜로 대체하여 테스트를 진행한다.


<br>

***

<br>

### ✔ jest 문법

<br>

*Integration Test를 실행할 때 test DB를 사용하는 것이 데이터 관리가 쉬워진다.

<br>

|문법|설명|
|:---:|:---:|
|.toBe(value)|입력받은 결과값과 동일한지 엄격하게 동일한지 비교한다.|
|.toEqual(value)|입력받은 결과값과 동일한지 비교한다.|
|.toMatch(regexp \| string)|입력받은 결과값과 문자열이 같은지 검증한다.|
|.toBeTruthy()|결과값이 true인지 검증인다.|
|.toBeInstanceOf(Class)|입력받은 값과 Class가 동일한 Instance인지 검증한다.|
|.toHaveProperty(keyPath, value?)|입력받은 객체의 Key와 Value가 일치하는지 검증한다.|
|.toMatchObject(object)|결과값의 객체와 입력받은 객체가 일치하는지 검증하되, 속성 수가 일치하지 않더라도 일치하게끔 검증한다.|
|.toHaveBeenCalledTimes(number)|Mock이 몇 번 호출되었는지 검증한다.|
|.toHaveBeenCalledWith(arg1, arg2, ...)|어떤 인자를 이용해 Mock가 호출되었는지 검사한다.|